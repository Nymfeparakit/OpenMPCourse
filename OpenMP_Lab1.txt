// OpenMP_Lab1.cpp : Defines the entry point for the console application.
//

#include "omp.h"
#include <random>
#include <iostream>
#include <sstream>
#include <chrono>
#include <string>
//const int rowCount = 100;
//const int columnCount = 100;

int main(int argc, char* argv[])
{
	int rowCount = atoi(argv[1]);
	int columnCount = atoi(argv[2]);
	
	//int matrix[rowCount][columnCount];
	int** matrix = new int* [rowCount];
	for (int i = 0; i < rowCount; ++i)
		matrix[i] = new int[columnCount];

	std::random_device dev;
	std::mt19937 rng(dev());
	std::uniform_int_distribution<std::mt19937::result_type> dist6(1, 20); // [1, 100]

	//std::cout << dist6(rng) << std::endl;
	//инициализация матрицы
	//std::cout << "Matrix" << std::endl;
	for (int i = 0; i < rowCount; ++i)
	{
		for (int j = 0; j < columnCount; ++j)
		{
			matrix[i][j] = dist6(rng);
			//std::cout << matrix[i][j] << " ";
		}

		//std::cout << std::endl;
	}
	int a = 0;

	//итоговый массив, содержаший кол-во семерок для каждой строки
	//long long numberOfSevensArr[rowCount] = { 0 };

	//выделяем память и инициализируем нулями
	int* numberOfSevensArr = new int[rowCount]();
	//numberOfSevensArr = { 0 };
	//int sumArr[columnCount] = { 0 };//массив, состоящий из попарных сумм для строки
	std::chrono::steady_clock sc;
	auto start = sc.now();     // запускаем таймер

	int numOfProcs = omp_get_num_procs();
#pragma omp parallel shared(matrix, numberOfSevensArr) num_threads(numOfProcs) 
	{
#pragma omp for schedule(static)//j,k,sum - private по умолчанию
//#pragma omp for
		for (int i = 0; i < rowCount; ++i)
		{
			for (int j = 0; j < columnCount; ++j)
			{
				for (int k = j + 1; k < columnCount; ++k)
				{
					//sumArr[k] = matrix[i][j] + matrix[i][k];//узнаем попарную сумму
					int sum = matrix[i][j] + matrix[i][k];//узнаем попарную сумму
					while (sum != 0)
					{
						//если число содержит 7
						if (sum % 10 == 7) ++numberOfSevensArr[i];
						sum /= 10;
					}
				}

			}
		}
		//выводим число потоков
#pragma omp single
		std::cout << "Num of threads: " << omp_get_num_threads() << std::endl;
		//std::string str("Hello, i'm thread N" + std::to_string(omp_get_thread_num()));
		//str += '\n';
		//std::string str = "Hello, i'm thread N" + std::to_string(omp_get_thread_num()) + '/n';
		//std::ostringstream os;
		//std::cout << str;
		//std::cout << "Hello, i'm thread N" << omp_get_thread_num();
		//std::cout << "Hello, i'm thread " << omp_get_num_threads() << std::endl;
	}

	auto end = sc.now();     // останавливаем таймер
	std::cout << "Time parallel: "
		<< std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count()
		<< " ms" << std::endl;

	//------теперь считаем без потоков
	int* numberOfSevensArr2 = new int[rowCount]();
	start = sc.now();     // запускаем таймер
		for (int i = 0; i < rowCount; ++i)
		{
			for (int j = 0; j < columnCount; ++j)
			{
				for (int k = j + 1; k < columnCount; ++k)
				{
					//sumArr[k] = matrix[i][j] + matrix[i][k];//узнаем попарную сумму
					int sum = matrix[i][j] + matrix[i][k];//узнаем попарную сумму
					while (sum != 0)
					{
						//если число содержит 7
						if (sum % 10 == 7) ++numberOfSevensArr2[i];
						sum /= 10;
					}
				}

			}
		}

	end = sc.now();     // останавливаем таймер
	std::cout << "Time: "
		<< std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count()
		<< " ms" << std::endl;

	//выводим результаты
	/*std::cout << "Results" << std::endl;
	for (int i = 0; i < rowCount; ++i)
	{
		std::cout << i << ": " << numberOfSevensArr[i] << std::endl;
	}*/

	//очищаем 
	for (int i = 0; i < rowCount; ++i) {
		delete[] matrix[i];
	}
	delete[] matrix;
	delete[] numberOfSevensArr;
	delete[] numberOfSevensArr2;

	return 0;
}

